use std::{
    process::{Child, Command, Stdio},
    sync::{Arc, Mutex},
};

pub struct OcrService {
    child: Arc<Mutex<Option<Child>>>,
}

impl OcrService {
    pub fn new() -> Self {
        Self {
            child: Arc::new(Mutex::new(None)),
        }
    }

    pub fn start(&self) -> Result<(), String> {
        let mut child_lock = self.child.lock().unwrap();

        // in DEV run script directly
        #[cfg(debug_assertions)]
        let mut command = {
            let mut cmd = Command::new("python3");
            cmd.arg("python/ocr_process.py");
            cmd
        };

        // in PROD run script generated by PyInstaller
        #[cfg(not(debug_assertions))]
        let mut command = {
            let mut cmd = Command::new("./ocr_process");
            cmd
        };

        let child = command
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| format!("Failed to spawn OCR: {}", e))?;

        *child_lock = Some(child);
        Ok(())
    }

    pub fn stop(&self) -> Result<(), String> {
        let mut child_lock = self.child.lock().unwrap();

        if let Some(mut child) = child_lock.take() {
            child.kill().map_err(|e| format!("Failed to kill: {}", e))?;
            child.wait().ok();
        }

        Ok(())
    }

    pub fn is_running(&self) -> bool {
        let mut child_lock = self.child.lock().unwrap();

        if let Some(child) = child_lock.as_mut() {
            match child.try_wait() {
                Ok(None) => true,
                _ => false,
            }
        } else {
            false
        }
    }
}

impl Drop for OcrService {
    fn drop(&mut self) {
        println!("Cleaning up OCR process...");
        self.stop().ok();
    }
}
